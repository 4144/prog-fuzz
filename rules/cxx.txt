"[void] [f] []([]) { [] }"
"[]; []"
"[]; []; [];
"[], []"
"{ [] }"
"( [] )"
"< [] >"
"\[[]\]"
"[a]\[[0]\]"
"while ([]) { [] }"
"switch [(x)] { case [0]: []; }"
"if ([x]) { [] } else { [] }"
"[x] ? [0] : [1]"
"typename []"
"[typename T]; [typename U]"
"[typename]... []"
"template<[typename T]> [struct {}];"
"template<[typename T]> struct [s] { [] };"
"template<[typename T]> [void] [f] ([]) { [] }"
"[] [int] [x]"
"[] [int] *[x]"
"[] [int] &[x]"
"[] [float] [x]"
"[] [double] [x]"
"[] struct [s] [{}] []"
"[] struct [s] { [] } []"
"[] class [s] [{}] []"
"[] class [s] { [] } []"
"[] union [s] [{}] []"
"[] union [s] { [] } []"
"[] enum [s] [{}] []"
"[] enum [s] { [] } []"
"[] [s](): [f]([x]) { [] }"
"[] ~[s]() { [] }"
"public: []"
"private: []"
"operator+([])"
"[0] + [0]"
"[0] - [0]"
"[0] << [0]"
"[0] >> [0]"
"[0] * [0]"
"[0] / [0]"
"~[0]"
"[0] && [0]"
"[0] || [0]"
"[char] []*"
"[char] []&"
"[char] []&&"
"const []"
"volatile []"
"mutable []"
"register []"
"thread_local []"
"noexcept []"
"typeid([])"
"virtual []"
"export []"
"friend []"
"reinterpret_cast<[int]>([x])"
"static_cast<[int]>([x])"
"const_cast<[int]>([x])"
"dynamic_cast<[int]>([x])"
"[void] [f]([]) const = 0;"
"constexpr [int] [f]([]) { return [0]; }"
"constexpr [int] f([]) { return [0]; } void [g]([]) { f([]); }"
"[f]([]);"
"\[[]\] ([]) {[]}"
"([x] = [0])"
"([x] == [0])"
"([x] % [0])"
"([x] %= [0])"
"([x] < [0])"
"([x] > [0])"
"unsigned [int]"
"unsigned long long int"
"long double"
"short"
"({ []; 0 })"
"[unsigned int] [b]:[1];"
"asm [volatile] (\"[]\" : \"=r\" ([x]) : \"r\" ([y])"
"[T]::[x]"
"&[x]"
"*[x]"
"[x].[y]"
"[x]->[y]"
"[extern] [void]"
"[static] [void]"
"[inline] [void]"
"typeof([x])"
"sizeof([x])"
"decltype([x])"
"alignof([x])"
"default:"
"([void]) [x]"
"[f]<[]>([])"
"[f][<>]([])"
"[int] [a]\[\] = [{}];"
"[int] [a]\[\] = { [] };"
"a"
"x"
"y"
"f"
"t"
"T"
"s"
"-1ULL"
"-1"
"0"
"1"
"2"
"l:"
"goto [l]; []"
"&&[l]"
"auto [x] = [f()];"
"break; []"
"continue; []"
"return [0]; []"
"namespace { [] } []"
"using [t] = [T]; []"
"try { [] } catch ([int] [x]) { [] }"
"new [x][()]"
"new [x]([])"
"delete [x]"
"throw [x]"
"static_assert([1])"
"typedef [int] [t]; []"

# callbacks
"[void] (*[cb])([])"
"[cb]->([])"
"[] [void] [f] []([void] (*[cb])([])) [] { []; [cb]->([]); [] }"
"struct [s] { []; [int] [f]; [void] m []([]) []; []; }"
"&[s]::[f]"
"&[s]::[m]"

# attributes
"__attribute__ (([]))"
"__attribute__ ((noinline([])))"
#"__attribute__ ((vector_size ([4])))"
#"__attribute__ ((noinline))"
#"__attribute__ ((noclone))"
#"__attribute__ ((aligned([16])))"
#"__attribute__ ((common))"
#"__attribute__ ((nocommon))"
#"__attribute__ ((sysv_abi))"
#"__attribute__ ((__naked__))"

# from gcc test suite
#"extern void abort (void) __attribute__ ((__noreturn__)); [int] [f] ([int] i) { if ([i]) return [i]; abort() }"
#"extern int foo1(); extern int foo2(); void foo(int n, int b) { int i, a; foo1(); a = (long)(b * ((double) [0.1])); for (i = 0; i < n; ++i) { foo2(a); [] } [] }"
#"typedef struct { unsigned char b0:1; unsigned char b[1]:1; [] } BitField; char acDummy\[0xf0\] __attribute__ ((__BELOW100__)); BitField B100A __attribute__ ((__BELOW100__)) = { 1, 0, [] }; char * Do(void) { if (B100A.b1) { [] } }"
#"extern void exit (int); typedef [long] [__m128i] __attribute__ ((__vector_size__ ([16]), [__may_alias__])); union { [__m128i] [i_align]; [long] i64\[[10240]\]; } a, b, c, d; void imul64 (void) { int i; for (i = 0; i < [10240]; [i++]) a.i64\[i\] = b.i64\[i\] * c.i64\[i\]; } int main () { imul64 (); exit (0); }"
#"[void *] p; [void] foo ([long unsigned int] len) { if ([len] < [2000 / sizeof (void *)]) p = __builtin_alloca (len * sizeof ([void *]));  else  p = __builtin_malloc (len * sizeof ([void *])); }"
#"template < [typename T] > struct na { typedef T * p; template < typename > struct r { typedef na o;}; }; template < typename T > struct a:public na < T > { [] }; template < typename T, typename c > struct v { typedef typename c::template r < [T] >::o t; struct { typename [t::p] _ms; typename [t::p] _mf; typename [t::p] _me; [];  }; }; template < typename T, typename c = a < T > >[struct V:v < T, c >] { typedef [v < T, c >] _Base; V ([]):_Base ([]) { [] } ~V(); []; }; struct l { l (int); V< struct _g >cs[]; V< [float] >db; }; l::l (int) { [] }"
#"struct A; extern struct A *a; struct A { [] } __attribute__((packed)); struct B __attribute__((aligned (sizeof (int)))); extern struct B *b; struct B { [int] i; []; []} __attribute__((packed)); int main() { [struct A] a; [struct B] b; return [0]; []; [] }"

# new
#"template <typename ... Args> struct pick_first []; template <typename T, typename ... Args > struct pick_first<T, Args ...> { using [type] = [T]; []; }; []; template <typename ... Args> using pick_first_t = typename pick_first<Args...>::type; []; template <typename Callable> struct deduce_first_parameter { private: template <typename Func, template <typename ...> typename [Operation]> struct extract_function []; []; template <typename R, typename ... Args, template <typename ...> typename Operation> struct extract_function<R(Args...), Operation> [] { using type = typename Operation<Args...>::type; []; }; template <typename C, typename R, typename ... Args, template <typename ...> typename Operation> [] struct extract_function<R (C::*)(Args...), Operation> [] { using type = typename Operation<Args...>::type; []; }; template <typename Func, template <typename ...> typename Operation> []  using extract_function_t = typename extract_function<Func, Operation>::[type]; []; public: using type = [] extract_function_t<[decltype](&[Callable]::[operator]([])), [pick_first]> []; []; }; []; template <typename R, typename ... InputArgs> [] struct deduce_first_parameter<R(InputArgs...)> { using type = pick_first_t<InputArgs...>; []; }; [];"
