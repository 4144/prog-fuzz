"[] fn [x][]([]) -> [][u32] { []; []; []; []; [0] } [] fn main() { []; []; []; []; [] }"
"[] fn [x][]([]) -> [] [{}]"
"[]; []"
"[] { [] } []"
"[] ([]) []"
"[x]x"
"[1]0"
"0"
"1"
"false"
"true"
"'x'"
"\[[]\]"
"[1], [2]"
"[1]; [2]"
"[1] + [2]"
"let x"
"let [x] = [5]"
"let [x]x = [x]"
"let ([x], [y]) = ([1], [2])"
"let [x]: [i32] = [5]"
"[x] = [10]"
"let [mut] [x] = [5]"
"i32"
"[x]: [i32]"
"\"foo\""
"println!(\"!\")"
"println!(\"{}\", [x]);"
"return [x]"
"!"
"[x].[len]()"
"x\[[0]\]"
"[0]..[1]"
"[0],"
"[x].[0]"
"[i32] { [x] }"
"if [x] [==] [5] { [] } else { [] }"
"loop { [] }"
"while [true] { [] }"
"[x] % [5] [==] [0]"
"for ([x] = [0]; [x] [<] [10]; [x++]) { [] }"
"for [x] in [0]..[10] { [] }"
"[x].enumerate()"
"break"
"continue"
"'[L]: []"
"break '[L]"
"continue '[L]"
"[] []"
"#[]\[allow(unused_variables)\]"
"#[]\[allow(unreachable_code)\]"
"#[]\[allow(dead_code)\]"
"!"
"let [x] = vec!\[[]\];"
"match [x].get([7]) { [] }"
"Some([x]) => [0]"
"None => [0]"
"mut [x]"
"&[] [mut] [x]"
""
"bool"
"Vec<[i32]>"
"|[x]| [x]"
"*x"
"&x"
"[x].[as_str]([])"
"'[a]"
"<[]>"
"<'[a]>"
"&'a [u32]"
"str"
"'[a]"
"impl"
"impl<'[a]> [Foo]<'[a]> { [] }"
"[Foo] { [] }"
"[x]: [x]"
"[x].[x]([])"
"static"
"[] use [std]::[cell]::[Cell]"
"[] struct [Foo] [] { [] }"
"assert_eq!([1], [1])"
"#\[derive(Debug)\]"
"[] struct [Foo]([])"
"[] enum [Foo] [] { [] }"
"[x]::[x]"
"String"
"[_] => [0],"
"['a'] ... ['z']"
"[x] @ [0] => 0,"
"[x] | [0] => 0,"
"const"
"Vec::new()"
"Vec::<[bool]>::new()"
"[x] * [x]"
"f64"
"3.14159216"
"assert!([1])"
"b\"whatever\""
"#\[derive([Debug])\]"
"impl [Drop] for [Foo] { [] }"
"Debug"
"Drop"
"Foo"
"*[mut] ([])"
"fn[](*[mut] ([]))"
"unsafe []"
"unsafe { [] }"
"Clone"
"&[x] as &[Clone]"
"|[x]| { [] }"
"|[x]: [i32]| { [] }"
"move |[x]: [i32]| { [] }"
"move"
"<[Foo] as [Foo]>"
"\[[u8]; [10]\]"
"[] pub"
"macro_rules! [vec] { ( $( $[x]:[expr] ),* ) => { [] } }"
"macro_rules! [x] { [] }"
"$( [] )*"
"$[x]"
"{{ [] }}"
"item"
"block"
"stmt"
"pat"
"expr"
"ty"
"ident"
"path"
"tt"
"meta"
"None?"
"Some([x])?"
"Some([x])"
"![true]"
"-[x]"
"[] mod [math] [{}]"
"#\[path = [\"x\"]\]"
"#!\[crate_name = [\"x\"]\]"
"#!\[crate_type = [\"lib\"]\] []"
"extern crate [std]"
"extern crate [std] as [std]"
"#\[link([name] = [\"x\"])"
"#\[cfg([test])\]"
"#\[[test]\]"
"#\[cfg(target_os=[\"linux\"])\]"
"#\[[crate_name]=[\"x\"]\]"
"#\[[plugin]([x])\]"
"crate_type"
"feature"
"no_builtins"
"no_main"
"no_start"
"no_std"
"plugin"
"recursion_limit"
"main"
"plugin_registrar"
"start"
"should_panic"
"cold"
"thread_local"
"link_args"
"link"
"linked_from"
"link_name"
"linkage"
"repr"
"macro_use"
"macro_reexport"
"macro_export"
"no_link"
"export_name"
"link_section"
"no_mangle"
"simd"
"unsafe_destructor_blind_to_params"
"unsafe_no_drop_flag"
"doc"
"rustc_on_unimplemented"
"debug_assertions"
"target_arch"
"target_endian"
"target_env"
"target_family"
"target_os"
"target_pointer_width"
"target_vendor"
"unix"
"windows"
"allow"
"deny"
"forbid"
"warn"
"lang"
"inline"
"inline(always)"
"inline(never)"
"derive([PartialEq], [Clone])"
"feature"
"advanced_slice_patterns"
"slice_patterns"
"asm"
"asm!"
"asm!([\"nop\"])"
"asm!(\"xor %eax, %eax\" : [] : [] : [\"eax\"])"
"asm!(\"in %dx, %al\" : \"={[al]}\"([x]) : \"{[dx]}\"([x]))"
"[panic]!([])"
"panic"
"file"
"line"
"debug_assert"
"array"
"bool"
"char"
"f32"
"f64"
"fn"
"i8"
"i16"
"i32"
"i64"
"isize"
"pointer"
"reference"
"slice"
"str"
"tuple"
"u8"
"u16"
"u32"
"u64"
"unit"
"usize"
"i128"
"u128"
"never"
